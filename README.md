# В данном репозитории приведен алгоритм, решающий задачу алгоритмизации исходного кода на EO

## Входные данные:

На вход алгоритму подается xml файл с описанием:
1) Control-flow графа, который представляет собой описание входной программы;
2) Перечня объектов, используемых в программе;
3) Перечня вершин control-flow графа, операции, соответствующие которым, невозможно транслировать на Rust.

В корневом теге <Graph> содержатся теги для описания вершин (\<vertices>), объектов (\<objects>) и вершин, запрещенных для транслирования на Rust (\<prohibitedToTransform>).

Каждая вершина должна находиться в дочернем элементе корня под названием \<vertices>. Уникальный идентификатор вершины ID - ее порядковый номер в списке вершин (индексация с 0).
Каждая вершина должна содержать следующие данные:
* \<executionTime> - тег, содержащий в себе еще 2 вложенных тега - \<EO> и \<RUST>, каждый из которых содержит ожидаемую трудозатратность выполнения операций, соответствующих данной вершине control-flow графа, на соответствующем языке (неотрицательное вещественное число);
* \<childIds> - целочисленное неотрицательное значение, уникальный идентификатор дочерней вершины. Если дочерних вершин несколько, они перечисляются по одной, каждая в новом теге \<childIds>.
* \<objectsToRead> - целочисленное неотрицательное значение, уникальный идентификатор объекта, который используется для чтения в фрагменте кода, соответствующем вершине. Если их несколько, перечисляются по одному, каждый в новом теге \<objectsToRead>;
* \<objectsToWrite> - целочисленное неотрицательное значение, уникальный идентификатор объекта, который модифицируется в фрагменте кода, соответствующем вершине. Если их несколько, то перечисляются по одному, каждый в новом теге \<objectsToWrite>.

Каждый объект должен находиться в дочернем элементе корня под названием \<objects>. Внутри тега должно быть только одно целое неотрицательное число - количество памяти, занимаемое объектом (в байтах).

Каждая вершина Control-flow графа, представленного во входных данных, должна соответствовать ровно одной атомарной операции. Control-flow граф должен содержать корневую вершину - точку входа в программу. Все точки выхода из программы должны быть представлены отдельными вершинами-стоками.

Пример входного xml файла: test_examples\test1.xml.

Уникальные идентификаторы вершин, которым соответствуют фрагменты кода, которые запрещено транслировать в Rust, перечисляются в тегах <prohibitedToTransform>, по одной в каждом теге.

## Выходные данные:
Выходными данными алгоритма является .json файл с описанием списков уникальных идентификаторов вершин, которые должны быть преобразованы в код на Rust.

Выходной .json файл должен содержать список из объектов "vertices", каждый из которых представляет из себя список целых чисел - уникальных идентификаторов вершин. В пределах одного "vertices" все операции, соответствующие данным вершинам в control-flow графе, должны быть преобразованы в одну вставку кода на Rust с помощью использования внешних функциональных интерфейсов языка EO.

Пример выходного .json файла: test_examples\result.json.

## Требования к алгоритму:
Алгоритм возвращает файл со списком "vertices", каждый из них представляет из себя список целых чисел. Каждый "vertices" представляет собой список уникальных идентификаторов вершин, таких, что все фрагменты кода, соответствующие этим вершинам, должны быть преобразованы в одну единую вставку кода на Rust. Требуется, чтобы после преобразования всех фрагментов кода, которые должны быть преобразованы согласно выходным данным алгоритма, получился корректный control-flow граф g' (изначальный control flow graph - g).

При этом должны выполняться следующие требования:

* g' - корректный control-flow граф;
* множество допустимых входных данных для программы, соответветствующей g, должно быть подмножеством множества допустимых входных данных для программы, соответствующей g';
* на всех входных данных из множества допустимых входных данных, выходные данные программ g и g' должны быть одинаковы;
* в результате преобразований, которые укажет алгоритм, должна быть получена программа, время выполнения которой должно быть не больше, чем время выполнения программы с аналогичным control-flow графом, написанной чисто на EO.